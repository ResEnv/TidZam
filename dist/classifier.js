// Generated by CoffeeScript 1.10.0
(function() {
  var Classifier, fs, spawn;

  spawn = require('child_process').spawn;

  fs = require('fs');

  Classifier = (function() {
    var ctr, me;

    me = Classifier;

    ctr = {};

    function Classifier(file, clb, show) {
      if (show == null) {
        show = "";
      }
      me.file = file;
      me.show = show;
      me.conf = {};
      me.clb = clb;
      me.classifiersPath = 'data/classifiers/';
      me.classifiers = [];
    }

    Classifier.prototype.init = function() {
      return this.getAvailableClassifiers(function(code, data) {
        if (code === 0) {
          me.classifiers = data;
          return me.prototype.start();
        } else {
          return console.log('Classifier initialization error');
        }
      });
    };

    Classifier.prototype.toggleClassifier = function(name, f) {
      return this.getAvailableClassifiers(function(code, data) {
        var cl, found, j, len, t;
        found = false;
        for (j = 0, len = data.length; j < len; j++) {
          cl = data[j];
          if (cl === 'classifier-' + name + '.nn') {
            if (me.classifiers.indexOf(cl) >= 0) {
              t = me.classifiers.splice(me.classifiers.indexOf(cl), 1);
              found = true;
            }
            break;
          }
        }
        if (!found) {
          me.classifiers.push('classifier-' + name + '.nn');
          t = 'classifier-' + name + '.nn';
        }
        me.prototype.reload();
        return f(0, t);
      });
    };

    Classifier.prototype.getConf = function() {
      return me.conf;
    };

    Classifier.prototype.getAvailableClassifiers = function(f) {
      var res;
      res = [];
      return fs.readdir(me.classifiersPath, function(err, items) {
        var j, len, nn;
        for (j = 0, len = items.length; j < len; j++) {
          nn = items[j];
          if (nn.indexOf('nn') > 0) {
            res.push(nn);
          }
        }
        return f(0, res);
      });
    };

    Classifier.prototype.reload = function() {
      this.stop();
      return this.start();
    };

    Classifier.prototype.stop = function() {
      return typeof ctr.kill === "function" ? ctr.kill('SIGTERM') : void 0;
    };

    Classifier.prototype.start = function() {
      var classifiers, msg, ready, tmp;
      tmp = classifiers = '[{"' + me.classifiers[0] + '"}';
      me.classifiers.forEach(function(item, i) {
        if (i > 0) {
          return classifiers += ',{"' + item + '"}';
        }
      });
      classifiers += ']';
      classifiers = classifiers.replace(/(?:\r\n|\r|\n)/g, 'gg');
      ctr = spawn('octave', ["./octave/predict.m", "--auto", "--stream=" + me.file, me.show, "--classifiers-path=" + me.classifiersPath, "--classifiers=" + classifiers]);
      msg = new String();
      ready = false;
      ctr.stderr.on('data', function(data) {
        return console.log(data.toString());
      });
      ctr.stdout.on('data', function(data) {
        var err, error, tmp2;
        if (data.toString().indexOf('Starting') !== -1) {
          ready = true;
        }
        if (!ready) {
          return;
        }
        tmp = data.toString().toString().split("\n");
        msg += tmp[0];
        if (tmp.length > 1) {
          try {
            tmp2 = JSON.parse(msg.toString());
            if (tmp2.classifiers) {
              me.conf = tmp2;
            }
          } catch (error) {
            err = error;
          }
          me.clb(0, msg);
          return msg = tmp[1];
        }
      });
      return ctr.stdout.on('close', function(code) {
        return console.log('Classifiers stopped');
      });
    };

    return Classifier;

  })();

  exports.Classifier = Classifier;

}).call(this);
